name: DevOps Assignment CI/CD Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:  # Allow manual 
    inputs:
      cleanup:
        description: 'Run cleanup job (destroy infrastructure)'
        required: false
        default: false
        type: boolean
      force_cleanup:
        description: 'Force cleanup even if infrastructure job failed'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: 1.5.0
  TERRAGRUNT_VERSION: 0.50.0

jobs:
  # Job 1: Infrastructure Deployment
  infrastructure:
    name: 🏗️ Deploy Infrastructure
    runs-on: ubuntu-latest
    
    # Set outputs for the next job
    outputs:
      s3-bucket-name: ${{ steps.terraform-output.outputs.s3_bucket_id }}
      cloudfront-url: ${{ steps.terraform-output.outputs.cloudfront_url }}
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
    
    - name: 🔧 Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: 🛠️ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
    
    - name: 📦 Install Terragrunt
      run: |
        wget https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64
        chmod +x terragrunt_linux_amd64
        sudo mv terragrunt_linux_amd64 /usr/local/bin/terragrunt
        terragrunt --version
    
    - name: 🗄️ Setup Local Backend with Artifacts
      run: |
        echo "🗄️ Using local backend with GitHub Actions artifacts for state persistence"
        echo "This ensures state is preserved between pipeline runs for up to 30 days"
        echo "✅ State will be available for new pipeline triggers"

    - name: 🔍 Terraform Format Check
      run: |
        cd terraform
        terraform fmt -check -recursive
      continue-on-error: true

    - name: 💾 Download Previous State
      uses: actions/download-artifact@v4
      with:
        name: terraform-state
        path: terragrunt/environments/dev/
      continue-on-error: true

    - name: 💾 Download Failed State (if no success state found)
      uses: actions/download-artifact@v4
      with:
        name: terraform-state-failed
        path: terragrunt/environments/dev/
      continue-on-error: true
    
    - name: 📋 Terragrunt Plan
      working-directory: terragrunt/environments/dev
      run: |
        echo "🗄️ Using local backend with artifact persistence"
        echo "📋 Initializing Terragrunt with local backend..."
        
        # The main terragrunt.hcl now uses local backend by default
        terragrunt init
        terragrunt plan -no-color
      env:
        TF_VAR_bucket_name: "devops-assignment-products-dev"
        TF_VAR_distribution_name: "devops-assignment-dev"
        TF_VAR_environment: "dev"
    
    - name: 🚀 Terragrunt Apply
      id: terragrunt-apply
      working-directory: terragrunt/environments/dev
      run: |
        echo "🚀 Applying infrastructure changes..."
        echo "🗄️ Using local backend configuration..."
        
        # The main terragrunt.hcl now uses local backend by default
        terragrunt init
        terragrunt apply -auto-approve -no-color
      env:
        TF_VAR_bucket_name: "devops-assignment-products-dev"
        TF_VAR_distribution_name: "devops-assignment-dev"
        TF_VAR_environment: "dev"
    
    - name: 📤 Get Terraform Outputs
      id: terraform-output
      working-directory: terragrunt/environments/dev
      # Only get outputs if apply succeeded
      if: steps.terragrunt-apply.outcome == 'success'
      run: |
        echo "Retrieving Terraform outputs..."
        S3_BUCKET=$(terragrunt output -raw s3_bucket_id)
        CLOUDFRONT_URL=$(terragrunt output -raw cloudfront_url)
        
        echo "s3_bucket_id=${S3_BUCKET}" >> $GITHUB_OUTPUT
        echo "cloudfront_url=${CLOUDFRONT_URL}" >> $GITHUB_OUTPUT
        echo "Infrastructure outputs:"
        echo "S3 Bucket: ${S3_BUCKET}"
        echo "CloudFront URL: ${CLOUDFRONT_URL}"

    - name: 💾 Upload State File (Success)
      uses: actions/upload-artifact@v4
      # Only upload state if apply succeeded
      if: steps.terragrunt-apply.outcome == 'success'
      with:
        name: terraform-state
        path: |
          terragrunt/environments/dev/terraform.tfstate
          terragrunt/environments/dev/.terraform/
        retention-days: 30
    
    - name: ⚠️ Upload State File (Partial Failure)
      uses: actions/upload-artifact@v4
      # Upload state even on failure to preserve partial changes for retry
      if: steps.terragrunt-apply.outcome == 'failure'
      with:
        name: terraform-state-failed
        path: |
          terragrunt/environments/dev/terraform.tfstate
          terragrunt/environments/dev/.terraform/
        retention-days: 7
    
    - name: ❌ Handle Apply Failure
      if: steps.terragrunt-apply.outcome == 'failure'
      run: |
        echo "❌ Terragrunt apply failed!"
        echo "⚠️ Partial infrastructure may have been created"
        echo "🗄️ Current state (including partial changes) saved as 'terraform-state-failed'"
        echo "🔄 On retry, the pipeline will continue from this state"
        echo "🔍 Check the apply logs above for error details"
        echo ""
        echo "To retry:"
        echo "1. Fix the underlying issue (permissions, etc.)"
        echo "2. Re-trigger the workflow"
        echo "3. Terraform will detect existing resources and continue"
        exit 1
  
  # Job 3: Cleanup (Optional - only on manual trigger)
  cleanup:
    name: 🧹 Cleanup Resources
    runs-on: ubuntu-latest
    needs: [infrastructure]
    # Run if: (normal cleanup after success) OR (force cleanup even after failure)
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.cleanup == 'true' && needs.infrastructure.result == 'success') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.force_cleanup == 'true')
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
    
    - name: 🔧 Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: 🛠️ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
    
    - name: 📦 Install Terragrunt
      run: |
        wget https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64
        chmod +x terragrunt_linux_amd64
        sudo mv terragrunt_linux_amd64 /usr/local/bin/terragrunt
    
    - name: 💾 Download Success State
      uses: actions/download-artifact@v4
      with:
        name: terraform-state
        path: terragrunt/environments/dev/
      continue-on-error: true
    
    - name: 💾 Download Failed State (for force cleanup)
      uses: actions/download-artifact@v4
      with:
        name: terraform-state-failed
        path: terragrunt/environments/dev/
      continue-on-error: true
    
    - name: ️ Terragrunt Destroy
      working-directory: terragrunt/environments/dev
      run: |
        echo "🗑️ Destroying infrastructure using local backend..."
        echo "🗄️ Using local backend configuration..."
        
        if [ "${{ github.event.inputs.force_cleanup }}" == "true" ]; then
          echo "⚠️  FORCE CLEANUP MODE: Destroying partial/failed infrastructure"
          echo "🔍 This will clean up any resources that were created before failure"
        else
          echo "✅ NORMAL CLEANUP MODE: Destroying successfully deployed infrastructure"
        fi
        
        # Initialize with current state and destroy
        terragrunt init
        terragrunt destroy -auto-approve -no-color
      env:
        TF_VAR_bucket_name: "devops-assignment-products-dev"
        TF_VAR_distribution_name: "devops-assignment-dev"
        TF_VAR_environment: "dev"
    
    - name: 🧹 Clean Success State Artifacts
      uses: geekyeggo/delete-artifact@v5
      with:
        name: terraform-state
      continue-on-error: true
    
    - name: 🧹 Clean Failed State Artifacts
      uses: geekyeggo/delete-artifact@v5
      with:
        name: terraform-state-failed
      continue-on-error: true