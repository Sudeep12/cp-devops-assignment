name: DevOps Assignment CI/CD Pipeline

on:
  push:
    branches: [ main, master ]
  # Removed pull_request trigger - only run on actual merges to main
  workflow_dispatch:  # Allow manual triggering
    inputs:
      cleanup:
        description: 'Run cleanup job (destroy infrastructure)'
        required: false
        default: false
        type: boolean
      force_cleanup:
        description: 'Force cleanup even if infrastructure job failed'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: 1.5.0
  TERRAGRUNT_VERSION: 0.50.0

jobs:
  # Job 1: Infrastructure Deployment
  infrastructure:
    name: 🏗️ Deploy Infrastructure
    runs-on: ubuntu-latest
    
    # Set outputs for the next job
    outputs:
      s3-bucket-name: ${{ steps.terraform-output.outputs.s3_bucket_id }}
      cloudfront-url: ${{ steps.terraform-output.outputs.cloudfront_url }}
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
    
    - name: 🔧 Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: 🛠️ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
    
    - name: 📦 Install Terragrunt
      run: |
        wget https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64
        chmod +x terragrunt_linux_amd64
        sudo mv terragrunt_linux_amd64 /usr/local/bin/terragrunt
        terragrunt --version
    
    - name: 🗄️ Setup S3 Backend
      run: |
        echo "🗄️ Using S3 backend for state storage"
        echo "📁 Bucket: sudeep-terraform-state"
        echo "🔒 State will be stored in S3 with encryption enabled"
        echo "✅ Remote state allows collaboration and persistence"
    
    - name: 🔍 Terraform Format Check
      run: |
        cd terraform
        terraform fmt -check -recursive
      continue-on-error: true
    
    - name:  Terragrunt Plan
      working-directory: terragrunt/environments/dev
      run: |
        echo "🗄️ Using S3 backend for state storage"
        echo "📋 Initializing Terragrunt with S3 backend..."
        
        terragrunt init
        terragrunt plan -no-color
      env:
        TF_VAR_bucket_name: "devops-assignment-products-dev"
        TF_VAR_distribution_name: "devops-assignment-dev"
        TF_VAR_environment: "dev"
    
    - name: 🚀 Terragrunt Apply
      id: terragrunt-apply
      working-directory: terragrunt/environments/dev
      run: |
        echo "🚀 Applying infrastructure changes..."
        echo "🗄️ Using S3 backend for state storage..."
        
        terragrunt init
        terragrunt apply -auto-approve -no-color
    
    - name: 📤 Get Terraform Outputs
      id: terraform-output
      working-directory: terragrunt/environments/dev
      # Only get outputs if apply succeeded
      if: steps.terragrunt-apply.outcome == 'success'
      run: |
        echo "Retrieving Terraform outputs..."
        S3_BUCKET=$(terragrunt output -raw s3_bucket_id)
        CLOUDFRONT_URL=$(terragrunt output -raw cloudfront_url)
        
        echo "s3_bucket_id=${S3_BUCKET}" >> $GITHUB_OUTPUT
        echo "cloudfront_url=${CLOUDFRONT_URL}" >> $GITHUB_OUTPUT
        echo "Infrastructure outputs:"
        echo "S3 Bucket: ${S3_BUCKET}"
        echo "CloudFront URL: ${CLOUDFRONT_URL}"
    
    - name: ❌ Handle Apply Failure
      if: steps.terragrunt-apply.outcome == 'failure'
      run: |
        echo "❌ Terragrunt apply failed!"
        echo "🗄️ S3 backend automatically preserves state up to the point of failure"
        echo "🔄 On retry, Terraform will continue from the last successful state"
        echo "🔍 Check the apply logs above for error details"
        echo ""
        echo "To retry:"
        echo "1. Fix the underlying issue (permissions, etc.)"
        echo "2. Re-trigger the workflow"  
        echo "3. Terraform will detect existing resources and continue"
        exit 1

  # Job 2: Cleanup (Optional - runs on manual trigger)
  cleanup:
    name: 🧹 Cleanup Resources
    runs-on: ubuntu-latest
    needs: [infrastructure]
    # Run cleanup when manually triggered
    if: github.event_name == 'workflow_dispatch' && (github.event.inputs.cleanup == 'true' || github.event.inputs.force_cleanup == 'true')
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
    
    - name: 🔧 Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: 🛠️ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
    
    - name: 📦 Install Terragrunt
      run: |
        wget https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64
        chmod +x terragrunt_linux_amd64
        sudo mv terragrunt_linux_amd64 /usr/local/bin/terragrunt
    
    - name: �️ Terragrunt Destroy
      working-directory: terragrunt/environments/dev
      run: |
        echo "🗑️ Destroying infrastructure using S3 backend..."
        echo "🗄️ S3 backend will automatically retrieve current state..."
        
        if [ "${{ github.event.inputs.force_cleanup }}" == "true" ]; then
          echo "⚠️  FORCE CLEANUP MODE: Destroying infrastructure regardless of previous job status"
        else
          echo "✅ NORMAL CLEANUP MODE: Destroying successfully deployed infrastructure"
        fi
        
        # Initialize with S3 backend and destroy
        terragrunt init
        terragrunt destroy -auto-approve -no-color
      env:
        TF_VAR_bucket_name: "devops-assignment-products-dev"
        TF_VAR_distribution_name: "devops-assignment-dev"
        TF_VAR_environment: "dev"