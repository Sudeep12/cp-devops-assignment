name: DevOps Assignment CI/CD Pipeline

on:
  push:
    branches: [ main, master ]
  # Removed pull_request trigger - only run on actual merges to main
  workflow_dispatch:  # Allow manual triggering
    inputs:
      cleanup:
        description: 'Run cleanup job (destroy infrastructure)'
        required: false
        default: false
        type: boolean
      force_cleanup:
        description: 'Force cleanup even if infrastructure job failed'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: 1.5.0
  TERRAGRUNT_VERSION: 0.50.0

jobs:
  # Job 1: Infrastructure Deployment
  infrastructure:
    name: ğŸ—ï¸ Deploy Infrastructure
    runs-on: ubuntu-latest
    
    # Set outputs for the next job
    outputs:
      s3-bucket-name: ${{ steps.terraform-output.outputs.s3_bucket_id }}
      cloudfront-url: ${{ steps.terraform-output.outputs.cloudfront_url }}
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
    
    - name: ğŸ”§ Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: ğŸ› ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
    
    - name: ğŸ“¦ Install Terragrunt
      run: |
        wget https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64
        chmod +x terragrunt_linux_amd64
        sudo mv terragrunt_linux_amd64 /usr/local/bin/terragrunt
        terragrunt --version
    
    - name: ğŸ—„ï¸ Setup S3 Backend
      run: |
        echo "ğŸ—„ï¸ Using S3 backend for state storage"
        echo "ğŸ“ Bucket: sudeep-terraform-state"
        echo "ğŸ”’ State will be stored in S3 with encryption enabled"
        echo "âœ… Remote state allows collaboration and persistence"
    
    - name: ğŸ” Terraform Format Check
      run: |
        cd terraform
        terraform fmt -check -recursive
      continue-on-error: true
    
    - name:  Terragrunt Plan
      working-directory: terragrunt/environments/dev
      run: |
        echo "ğŸ—„ï¸ Using S3 backend for state storage"
        echo "ğŸ“‹ Initializing Terragrunt with S3 backend..."
        
        terragrunt init
        terragrunt plan -no-color
      env:
        TF_VAR_bucket_name: "devops-assignment-products-dev"
        TF_VAR_distribution_name: "devops-assignment-dev"
        TF_VAR_environment: "dev"
    
    - name: ğŸš€ Terragrunt Apply
      id: terragrunt-apply
      working-directory: terragrunt/environments/dev
      run: |
        echo "ğŸš€ Applying infrastructure changes..."
        echo "ğŸ—„ï¸ Using S3 backend for state storage..."
        
        terragrunt init
        terragrunt apply -auto-approve -no-color
    
    - name: ğŸ“¤ Get Terraform Outputs
      id: terraform-output
      working-directory: terragrunt/environments/dev
      # Only get outputs if apply succeeded
      if: steps.terragrunt-apply.outcome == 'success'
      run: |
        echo "Retrieving Terraform outputs..."
        S3_BUCKET=$(terragrunt output -raw s3_bucket_id)
        CLOUDFRONT_URL=$(terragrunt output -raw cloudfront_url)
        
        echo "s3_bucket_id=${S3_BUCKET}" >> $GITHUB_OUTPUT
        echo "cloudfront_url=${CLOUDFRONT_URL}" >> $GITHUB_OUTPUT
        echo "Infrastructure outputs:"
        echo "S3 Bucket: ${S3_BUCKET}"
        echo "CloudFront URL: ${CLOUDFRONT_URL}"
    
    - name: âŒ Handle Apply Failure
      if: steps.terragrunt-apply.outcome == 'failure'
      run: |
        echo "âŒ Terragrunt apply failed!"
        echo "ğŸ—„ï¸ S3 backend automatically preserves state up to the point of failure"
        echo "ğŸ”„ On retry, Terraform will continue from the last successful state"
        echo "ğŸ” Check the apply logs above for error details"
        echo ""
        echo "To retry:"
        echo "1. Fix the underlying issue (permissions, etc.)"
        echo "2. Re-trigger the workflow"  
        echo "3. Terraform will detect existing resources and continue"
        exit 1

  # Job 2: Cleanup (Optional - runs on manual trigger)
  cleanup:
    name: ğŸ§¹ Cleanup Resources
    runs-on: ubuntu-latest
    needs: [infrastructure]
    # Run cleanup when manually triggered
    if: github.event_name == 'workflow_dispatch' && (github.event.inputs.cleanup == 'true' || github.event.inputs.force_cleanup == 'true')
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
    
    - name: ğŸ”§ Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: ğŸ› ï¸ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
    
    - name: ğŸ“¦ Install Terragrunt
      run: |
        wget https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64
        chmod +x terragrunt_linux_amd64
        sudo mv terragrunt_linux_amd64 /usr/local/bin/terragrunt
    
    - name: ï¿½ï¸ Terragrunt Destroy
      working-directory: terragrunt/environments/dev
      run: |
        echo "ğŸ—‘ï¸ Destroying infrastructure using S3 backend..."
        echo "ğŸ—„ï¸ S3 backend will automatically retrieve current state..."
        
        if [ "${{ github.event.inputs.force_cleanup }}" == "true" ]; then
          echo "âš ï¸  FORCE CLEANUP MODE: Destroying infrastructure regardless of previous job status"
        else
          echo "âœ… NORMAL CLEANUP MODE: Destroying successfully deployed infrastructure"
        fi
        
        # Initialize with S3 backend and destroy
        terragrunt init
        terragrunt destroy -auto-approve -no-color
      env:
        TF_VAR_bucket_name: "devops-assignment-products-dev"
        TF_VAR_distribution_name: "devops-assignment-dev"
        TF_VAR_environment: "dev"